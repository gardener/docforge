// SPDX-FileCopyrightText: 2021 SAP SE or an SAP affiliate company and Gardener contributors
//
// SPDX-License-Identifier: Apache-2.0
// Code generated by counterfeiter. DO NOT EDIT.
package resourcehandlersfakes

import (
	"context"
	"sync"

	"github.com/gardener/docforge/pkg/api"
	"github.com/gardener/docforge/pkg/resourcehandlers"
	"github.com/gardener/docforge/pkg/util/httpclient"
)

type FakeResourceHandler struct {
	AcceptStub        func(string) bool
	acceptMutex       sync.RWMutex
	acceptArgsForCall []struct {
		arg1 string
	}
	acceptReturns struct {
		result1 bool
	}
	acceptReturnsOnCall map[int]struct {
		result1 bool
	}
	BuildAbsLinkStub        func(string, string) (string, error)
	buildAbsLinkMutex       sync.RWMutex
	buildAbsLinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	buildAbsLinkReturns struct {
		result1 string
		result2 error
	}
	buildAbsLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetClientStub        func() httpclient.Client
	getClientMutex       sync.RWMutex
	getClientArgsForCall []struct {
	}
	getClientReturns struct {
		result1 httpclient.Client
	}
	getClientReturnsOnCall map[int]struct {
		result1 httpclient.Client
	}
	GetRawFormatLinkStub        func(string) (string, error)
	getRawFormatLinkMutex       sync.RWMutex
	getRawFormatLinkArgsForCall []struct {
		arg1 string
	}
	getRawFormatLinkReturns struct {
		result1 string
		result2 error
	}
	getRawFormatLinkReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ReadStub        func(context.Context, string) ([]byte, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	readReturns struct {
		result1 []byte
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ReadGitInfoStub        func(context.Context, string) ([]byte, error)
	readGitInfoMutex       sync.RWMutex
	readGitInfoArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	readGitInfoReturns struct {
		result1 []byte
		result2 error
	}
	readGitInfoReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ResolveDocumentationStub        func(context.Context, string) (*api.Documentation, error)
	resolveDocumentationMutex       sync.RWMutex
	resolveDocumentationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	resolveDocumentationReturns struct {
		result1 *api.Documentation
		result2 error
	}
	resolveDocumentationReturnsOnCall map[int]struct {
		result1 *api.Documentation
		result2 error
	}
	ResolveNodeSelectorStub        func(context.Context, *api.Node) ([]*api.Node, error)
	resolveNodeSelectorMutex       sync.RWMutex
	resolveNodeSelectorArgsForCall []struct {
		arg1 context.Context
		arg2 *api.Node
	}
	resolveNodeSelectorReturns struct {
		result1 []*api.Node
		result2 error
	}
	resolveNodeSelectorReturnsOnCall map[int]struct {
		result1 []*api.Node
		result2 error
	}
	ResourceNameStub        func(string) (string, string)
	resourceNameMutex       sync.RWMutex
	resourceNameArgsForCall []struct {
		arg1 string
	}
	resourceNameReturns struct {
		result1 string
		result2 string
	}
	resourceNameReturnsOnCall map[int]struct {
		result1 string
		result2 string
	}
	SetVersionStub        func(string, string) (string, error)
	setVersionMutex       sync.RWMutex
	setVersionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setVersionReturns struct {
		result1 string
		result2 error
	}
	setVersionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceHandler) Accept(arg1 string) bool {
	fake.acceptMutex.Lock()
	ret, specificReturn := fake.acceptReturnsOnCall[len(fake.acceptArgsForCall)]
	fake.acceptArgsForCall = append(fake.acceptArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AcceptStub
	fakeReturns := fake.acceptReturns
	fake.recordInvocation("Accept", []interface{}{arg1})
	fake.acceptMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceHandler) AcceptCallCount() int {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	return len(fake.acceptArgsForCall)
}

func (fake *FakeResourceHandler) AcceptCalls(stub func(string) bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = stub
}

func (fake *FakeResourceHandler) AcceptArgsForCall(i int) string {
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	argsForCall := fake.acceptArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) AcceptReturns(result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	fake.acceptReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResourceHandler) AcceptReturnsOnCall(i int, result1 bool) {
	fake.acceptMutex.Lock()
	defer fake.acceptMutex.Unlock()
	fake.AcceptStub = nil
	if fake.acceptReturnsOnCall == nil {
		fake.acceptReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.acceptReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeResourceHandler) BuildAbsLink(arg1 string, arg2 string) (string, error) {
	fake.buildAbsLinkMutex.Lock()
	ret, specificReturn := fake.buildAbsLinkReturnsOnCall[len(fake.buildAbsLinkArgsForCall)]
	fake.buildAbsLinkArgsForCall = append(fake.buildAbsLinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.BuildAbsLinkStub
	fakeReturns := fake.buildAbsLinkReturns
	fake.recordInvocation("BuildAbsLink", []interface{}{arg1, arg2})
	fake.buildAbsLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) BuildAbsLinkCallCount() int {
	fake.buildAbsLinkMutex.RLock()
	defer fake.buildAbsLinkMutex.RUnlock()
	return len(fake.buildAbsLinkArgsForCall)
}

func (fake *FakeResourceHandler) BuildAbsLinkCalls(stub func(string, string) (string, error)) {
	fake.buildAbsLinkMutex.Lock()
	defer fake.buildAbsLinkMutex.Unlock()
	fake.BuildAbsLinkStub = stub
}

func (fake *FakeResourceHandler) BuildAbsLinkArgsForCall(i int) (string, string) {
	fake.buildAbsLinkMutex.RLock()
	defer fake.buildAbsLinkMutex.RUnlock()
	argsForCall := fake.buildAbsLinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) BuildAbsLinkReturns(result1 string, result2 error) {
	fake.buildAbsLinkMutex.Lock()
	defer fake.buildAbsLinkMutex.Unlock()
	fake.BuildAbsLinkStub = nil
	fake.buildAbsLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) BuildAbsLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.buildAbsLinkMutex.Lock()
	defer fake.buildAbsLinkMutex.Unlock()
	fake.BuildAbsLinkStub = nil
	if fake.buildAbsLinkReturnsOnCall == nil {
		fake.buildAbsLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.buildAbsLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) GetClient() httpclient.Client {
	fake.getClientMutex.Lock()
	ret, specificReturn := fake.getClientReturnsOnCall[len(fake.getClientArgsForCall)]
	fake.getClientArgsForCall = append(fake.getClientArgsForCall, struct {
	}{})
	stub := fake.GetClientStub
	fakeReturns := fake.getClientReturns
	fake.recordInvocation("GetClient", []interface{}{})
	fake.getClientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceHandler) GetClientCallCount() int {
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	return len(fake.getClientArgsForCall)
}

func (fake *FakeResourceHandler) GetClientCalls(stub func() httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = stub
}

func (fake *FakeResourceHandler) GetClientReturns(result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	fake.getClientReturns = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeResourceHandler) GetClientReturnsOnCall(i int, result1 httpclient.Client) {
	fake.getClientMutex.Lock()
	defer fake.getClientMutex.Unlock()
	fake.GetClientStub = nil
	if fake.getClientReturnsOnCall == nil {
		fake.getClientReturnsOnCall = make(map[int]struct {
			result1 httpclient.Client
		})
	}
	fake.getClientReturnsOnCall[i] = struct {
		result1 httpclient.Client
	}{result1}
}

func (fake *FakeResourceHandler) GetRawFormatLink(arg1 string) (string, error) {
	fake.getRawFormatLinkMutex.Lock()
	ret, specificReturn := fake.getRawFormatLinkReturnsOnCall[len(fake.getRawFormatLinkArgsForCall)]
	fake.getRawFormatLinkArgsForCall = append(fake.getRawFormatLinkArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetRawFormatLinkStub
	fakeReturns := fake.getRawFormatLinkReturns
	fake.recordInvocation("GetRawFormatLink", []interface{}{arg1})
	fake.getRawFormatLinkMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) GetRawFormatLinkCallCount() int {
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	return len(fake.getRawFormatLinkArgsForCall)
}

func (fake *FakeResourceHandler) GetRawFormatLinkCalls(stub func(string) (string, error)) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = stub
}

func (fake *FakeResourceHandler) GetRawFormatLinkArgsForCall(i int) string {
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	argsForCall := fake.getRawFormatLinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) GetRawFormatLinkReturns(result1 string, result2 error) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = nil
	fake.getRawFormatLinkReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) GetRawFormatLinkReturnsOnCall(i int, result1 string, result2 error) {
	fake.getRawFormatLinkMutex.Lock()
	defer fake.getRawFormatLinkMutex.Unlock()
	fake.GetRawFormatLinkStub = nil
	if fake.getRawFormatLinkReturnsOnCall == nil {
		fake.getRawFormatLinkReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getRawFormatLinkReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) Read(arg1 context.Context, arg2 string) ([]byte, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1, arg2})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeResourceHandler) ReadCalls(stub func(context.Context, string) ([]byte, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeResourceHandler) ReadArgsForCall(i int) (context.Context, string) {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) ReadReturns(result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ReadReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ReadGitInfo(arg1 context.Context, arg2 string) ([]byte, error) {
	fake.readGitInfoMutex.Lock()
	ret, specificReturn := fake.readGitInfoReturnsOnCall[len(fake.readGitInfoArgsForCall)]
	fake.readGitInfoArgsForCall = append(fake.readGitInfoArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ReadGitInfoStub
	fakeReturns := fake.readGitInfoReturns
	fake.recordInvocation("ReadGitInfo", []interface{}{arg1, arg2})
	fake.readGitInfoMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ReadGitInfoCallCount() int {
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	return len(fake.readGitInfoArgsForCall)
}

func (fake *FakeResourceHandler) ReadGitInfoCalls(stub func(context.Context, string) ([]byte, error)) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = stub
}

func (fake *FakeResourceHandler) ReadGitInfoArgsForCall(i int) (context.Context, string) {
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	argsForCall := fake.readGitInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) ReadGitInfoReturns(result1 []byte, result2 error) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = nil
	fake.readGitInfoReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ReadGitInfoReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.readGitInfoMutex.Lock()
	defer fake.readGitInfoMutex.Unlock()
	fake.ReadGitInfoStub = nil
	if fake.readGitInfoReturnsOnCall == nil {
		fake.readGitInfoReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.readGitInfoReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ResolveDocumentation(arg1 context.Context, arg2 string) (*api.Documentation, error) {
	fake.resolveDocumentationMutex.Lock()
	ret, specificReturn := fake.resolveDocumentationReturnsOnCall[len(fake.resolveDocumentationArgsForCall)]
	fake.resolveDocumentationArgsForCall = append(fake.resolveDocumentationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ResolveDocumentationStub
	fakeReturns := fake.resolveDocumentationReturns
	fake.recordInvocation("ResolveDocumentation", []interface{}{arg1, arg2})
	fake.resolveDocumentationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ResolveDocumentationCallCount() int {
	fake.resolveDocumentationMutex.RLock()
	defer fake.resolveDocumentationMutex.RUnlock()
	return len(fake.resolveDocumentationArgsForCall)
}

func (fake *FakeResourceHandler) ResolveDocumentationCalls(stub func(context.Context, string) (*api.Documentation, error)) {
	fake.resolveDocumentationMutex.Lock()
	defer fake.resolveDocumentationMutex.Unlock()
	fake.ResolveDocumentationStub = stub
}

func (fake *FakeResourceHandler) ResolveDocumentationArgsForCall(i int) (context.Context, string) {
	fake.resolveDocumentationMutex.RLock()
	defer fake.resolveDocumentationMutex.RUnlock()
	argsForCall := fake.resolveDocumentationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) ResolveDocumentationReturns(result1 *api.Documentation, result2 error) {
	fake.resolveDocumentationMutex.Lock()
	defer fake.resolveDocumentationMutex.Unlock()
	fake.ResolveDocumentationStub = nil
	fake.resolveDocumentationReturns = struct {
		result1 *api.Documentation
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ResolveDocumentationReturnsOnCall(i int, result1 *api.Documentation, result2 error) {
	fake.resolveDocumentationMutex.Lock()
	defer fake.resolveDocumentationMutex.Unlock()
	fake.ResolveDocumentationStub = nil
	if fake.resolveDocumentationReturnsOnCall == nil {
		fake.resolveDocumentationReturnsOnCall = make(map[int]struct {
			result1 *api.Documentation
			result2 error
		})
	}
	fake.resolveDocumentationReturnsOnCall[i] = struct {
		result1 *api.Documentation
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ResolveNodeSelector(arg1 context.Context, arg2 *api.Node) ([]*api.Node, error) {
	fake.resolveNodeSelectorMutex.Lock()
	ret, specificReturn := fake.resolveNodeSelectorReturnsOnCall[len(fake.resolveNodeSelectorArgsForCall)]
	fake.resolveNodeSelectorArgsForCall = append(fake.resolveNodeSelectorArgsForCall, struct {
		arg1 context.Context
		arg2 *api.Node
	}{arg1, arg2})
	stub := fake.ResolveNodeSelectorStub
	fakeReturns := fake.resolveNodeSelectorReturns
	fake.recordInvocation("ResolveNodeSelector", []interface{}{arg1, arg2})
	fake.resolveNodeSelectorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ResolveNodeSelectorCallCount() int {
	fake.resolveNodeSelectorMutex.RLock()
	defer fake.resolveNodeSelectorMutex.RUnlock()
	return len(fake.resolveNodeSelectorArgsForCall)
}

func (fake *FakeResourceHandler) ResolveNodeSelectorCalls(stub func(context.Context, *api.Node) ([]*api.Node, error)) {
	fake.resolveNodeSelectorMutex.Lock()
	defer fake.resolveNodeSelectorMutex.Unlock()
	fake.ResolveNodeSelectorStub = stub
}

func (fake *FakeResourceHandler) ResolveNodeSelectorArgsForCall(i int) (context.Context, *api.Node) {
	fake.resolveNodeSelectorMutex.RLock()
	defer fake.resolveNodeSelectorMutex.RUnlock()
	argsForCall := fake.resolveNodeSelectorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) ResolveNodeSelectorReturns(result1 []*api.Node, result2 error) {
	fake.resolveNodeSelectorMutex.Lock()
	defer fake.resolveNodeSelectorMutex.Unlock()
	fake.ResolveNodeSelectorStub = nil
	fake.resolveNodeSelectorReturns = struct {
		result1 []*api.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ResolveNodeSelectorReturnsOnCall(i int, result1 []*api.Node, result2 error) {
	fake.resolveNodeSelectorMutex.Lock()
	defer fake.resolveNodeSelectorMutex.Unlock()
	fake.ResolveNodeSelectorStub = nil
	if fake.resolveNodeSelectorReturnsOnCall == nil {
		fake.resolveNodeSelectorReturnsOnCall = make(map[int]struct {
			result1 []*api.Node
			result2 error
		})
	}
	fake.resolveNodeSelectorReturnsOnCall[i] = struct {
		result1 []*api.Node
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) ResourceName(arg1 string) (string, string) {
	fake.resourceNameMutex.Lock()
	ret, specificReturn := fake.resourceNameReturnsOnCall[len(fake.resourceNameArgsForCall)]
	fake.resourceNameArgsForCall = append(fake.resourceNameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResourceNameStub
	fakeReturns := fake.resourceNameReturns
	fake.recordInvocation("ResourceName", []interface{}{arg1})
	fake.resourceNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) ResourceNameCallCount() int {
	fake.resourceNameMutex.RLock()
	defer fake.resourceNameMutex.RUnlock()
	return len(fake.resourceNameArgsForCall)
}

func (fake *FakeResourceHandler) ResourceNameCalls(stub func(string) (string, string)) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = stub
}

func (fake *FakeResourceHandler) ResourceNameArgsForCall(i int) string {
	fake.resourceNameMutex.RLock()
	defer fake.resourceNameMutex.RUnlock()
	argsForCall := fake.resourceNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceHandler) ResourceNameReturns(result1 string, result2 string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = nil
	fake.resourceNameReturns = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeResourceHandler) ResourceNameReturnsOnCall(i int, result1 string, result2 string) {
	fake.resourceNameMutex.Lock()
	defer fake.resourceNameMutex.Unlock()
	fake.ResourceNameStub = nil
	if fake.resourceNameReturnsOnCall == nil {
		fake.resourceNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
		})
	}
	fake.resourceNameReturnsOnCall[i] = struct {
		result1 string
		result2 string
	}{result1, result2}
}

func (fake *FakeResourceHandler) SetVersion(arg1 string, arg2 string) (string, error) {
	fake.setVersionMutex.Lock()
	ret, specificReturn := fake.setVersionReturnsOnCall[len(fake.setVersionArgsForCall)]
	fake.setVersionArgsForCall = append(fake.setVersionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetVersionStub
	fakeReturns := fake.setVersionReturns
	fake.recordInvocation("SetVersion", []interface{}{arg1, arg2})
	fake.setVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceHandler) SetVersionCallCount() int {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	return len(fake.setVersionArgsForCall)
}

func (fake *FakeResourceHandler) SetVersionCalls(stub func(string, string) (string, error)) {
	fake.setVersionMutex.Lock()
	defer fake.setVersionMutex.Unlock()
	fake.SetVersionStub = stub
}

func (fake *FakeResourceHandler) SetVersionArgsForCall(i int) (string, string) {
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	argsForCall := fake.setVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceHandler) SetVersionReturns(result1 string, result2 error) {
	fake.setVersionMutex.Lock()
	defer fake.setVersionMutex.Unlock()
	fake.SetVersionStub = nil
	fake.setVersionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) SetVersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.setVersionMutex.Lock()
	defer fake.setVersionMutex.Unlock()
	fake.SetVersionStub = nil
	if fake.setVersionReturnsOnCall == nil {
		fake.setVersionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.setVersionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceHandler) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acceptMutex.RLock()
	defer fake.acceptMutex.RUnlock()
	fake.buildAbsLinkMutex.RLock()
	defer fake.buildAbsLinkMutex.RUnlock()
	fake.getClientMutex.RLock()
	defer fake.getClientMutex.RUnlock()
	fake.getRawFormatLinkMutex.RLock()
	defer fake.getRawFormatLinkMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.readGitInfoMutex.RLock()
	defer fake.readGitInfoMutex.RUnlock()
	fake.resolveDocumentationMutex.RLock()
	defer fake.resolveDocumentationMutex.RUnlock()
	fake.resolveNodeSelectorMutex.RLock()
	defer fake.resolveNodeSelectorMutex.RUnlock()
	fake.resourceNameMutex.RLock()
	defer fake.resourceNameMutex.RUnlock()
	fake.setVersionMutex.RLock()
	defer fake.setVersionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceHandler) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ resourcehandlers.ResourceHandler = new(FakeResourceHandler)
